pub union InOutUnion < Input , Output > { producer : :: core :: mem :: ManuallyDrop < Input > , transformer : :: core :: mem :: ManuallyDrop < Output > , consumer : :: core :: mem :: ManuallyDrop < () > , } impl < Input , Output > :: std :: default :: Default for InOutUnion < Input , Output > { fn default () -> Self { Self { consumer : :: core :: mem :: ManuallyDrop :: < () > :: default () } } } impl < Input , Output > :: core :: convert :: From < () > for InOutUnion < Input , Output > { fn from (val : ()) -> Self { Self { consumer : :: core :: mem :: ManuallyDrop :: new (val) } } } # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (usize)] pub enum InOutUnionTag { Producer = 0usize , Transformer = 1usize , Consumer = 2usize } impl :: core :: convert :: From < InOutUnionTag > for usize { fn from (val : InOutUnionTag) -> usize { val as usize } } # [derive (Debug)] pub struct InOutUnionTagTryFromError (usize) ; impl :: std :: fmt :: Display for InOutUnionTagTryFromError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { write ! (f , "attempted to turn {} into {}" , self . 0 , stringify ! (InOutUnionTag)) } } impl :: core :: convert :: TryFrom < usize > for InOutUnionTag { type Error = InOutUnionTagTryFromError ; fn try_from (value : usize) -> :: std :: result :: Result < Self , Self :: Error > { match value { x if x == Self :: Producer as usize => Ok (InOutUnionTag :: Producer) , x if x == Self :: Transformer as usize => Ok (InOutUnionTag :: Transformer) , x if x == Self :: Consumer as usize => Ok (InOutUnionTag :: Consumer) , x => Err (InOutUnionTagTryFromError (x)) , } } } impl :: fastfifo :: transform :: config :: FifoTag for InOutUnionTag { fn is_atomic (self) -> bool { match self { Self :: Producer => false , Self :: Transformer => true , Self :: Consumer => false , } } fn chases (self) -> Self { match self { Self :: Producer => Self :: Consumer , Self :: Transformer => Self :: Producer , Self :: Consumer => Self :: Transformer , } } fn producer () -> Self { Self :: Producer } fn num_transformations () -> usize { 3usize } } impl < Input , Output > :: fastfifo :: transform :: config :: IndexedDrop < InOutUnionTag > for InOutUnion < Input , Output > { unsafe fn tagged_drop (& mut self , tag : InOutUnionTag) { match tag { InOutUnionTag :: Producer => unsafe { :: core :: mem :: ManuallyDrop :: drop (& mut self . producer) } , InOutUnionTag :: Transformer => unsafe { :: core :: mem :: ManuallyDrop :: drop (& mut self . transformer) } , InOutUnionTag :: Consumer => unsafe { :: core :: mem :: ManuallyDrop :: drop (& mut self . consumer) } , } } } pub struct InOutUnionFifo < Input , Output , A : :: std :: alloc :: Allocator = :: std :: alloc :: Global > (:: fastfifo :: transform :: FastFifo < InOutUnionTag , InOutUnion < Input , Output > , A > ,) ; impl < Input , Output , A : :: std :: alloc :: Allocator > :: fastfifo :: transform :: config :: TaggedClone < InOutUnionTag > for InOutUnionFifo < Input , Output , A > { fn unchecked_clone (& self) -> Self { Self (self . 0 . unchecked_clone ()) } } impl < Input , Output > InOutUnionFifo < Input , Output > { # [allow (dead_code)] pub fn new (num_blocks : usize , block_size : usize) -> Self { Self (:: fastfifo :: transform :: FastFifo :: new (num_blocks , block_size)) } } impl < Input , Output , A : :: std :: alloc :: Allocator > InOutUnionFifo < Input , Output , A > { # [allow (dead_code)] pub fn new_in (num_blocks : usize , block_size : usize , alloc : A) -> Self { Self (:: fastfifo :: transform :: FastFifo :: new_in (num_blocks , block_size , alloc)) } # [allow (dead_code)] pub fn get_entry (& self , tag : InOutUnionTag) -> :: fastfifo :: transform :: Result < :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < '_ , InOutUnionTag , InOutUnion < Input , Output > , A >> { self . 0 . get_entry (tag) } # [allow (dead_code)] pub fn split (self) -> (InOutUnionProducerFifo < Input , Output , A > , InOutUnionTransformerFifo < Input , Output , A > , InOutUnionConsumerFifo < Input , Output , A > ,) { (InOutUnionProducerFifo (< Self as :: fastfifo :: transform :: config :: TaggedClone < InOutUnionTag >> :: unchecked_clone (& self)) , InOutUnionTransformerFifo (< Self as :: fastfifo :: transform :: config :: TaggedClone < InOutUnionTag >> :: unchecked_clone (& self)) , InOutUnionConsumerFifo (< Self as :: fastfifo :: transform :: config :: TaggedClone < InOutUnionTag >> :: unchecked_clone (& self)) ,) } } pub struct InOutUnionProducerEntry < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > (:: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >) ; impl < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > From < :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >> for InOutUnionProducerEntry < 'entry_descriptor_lifetime , Input , Output , A > { fn from (value : :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >) -> Self { Self (value) } } impl < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > Into < :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >> for InOutUnionProducerEntry < 'entry_descriptor_lifetime , Input , Output , A > { fn into (self) -> :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A > { self . 0 } } impl < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > InOutUnionProducerEntry < 'entry_descriptor_lifetime , Input , Output , A > { # [allow (dead_code)] pub fn transform < F : :: std :: ops :: FnOnce () -> Input > (& mut self , transformer : F) { self . 0 . modify_t_in_place (| ptr | unsafe { ptr . write (InOutUnion { producer : :: core :: mem :: ManuallyDrop :: new (transformer ()) }) }) } } pub struct InOutUnionProducerFifo < Input , Output , A : :: std :: alloc :: Allocator > (InOutUnionFifo < Input , Output , A >) ; impl < Input , Output , A : :: std :: alloc :: Allocator > :: fastfifo :: transform :: config :: TaggedClone < InOutUnionTag > for InOutUnionProducerFifo < Input , Output , A > { fn unchecked_clone (& self) -> Self { Self (self . 0 . unchecked_clone ()) } } impl < Input , Output , A : :: std :: alloc :: Allocator > Clone for InOutUnionProducerFifo < Input , Output , A > { fn clone (& self) -> Self { < Self as :: fastfifo :: transform :: config :: TaggedClone < InOutUnionTag >> :: tagged_clone (& self , InOutUnionTag :: Producer) . expect ("this variant was marked with `atomic = false` and cannot be cloned") } } impl < Input , Output , A : :: std :: alloc :: Allocator > InOutUnionProducerFifo < Input , Output , A > { # [allow (dead_code)] pub fn get_entry < 'entry_descriptor_lifetime > (& 'entry_descriptor_lifetime self) -> :: fastfifo :: transform :: Result < InOutUnionProducerEntry < 'entry_descriptor_lifetime , Input , Output , A > > { self . 0 . get_entry (InOutUnionTag :: Producer) . map (InOutUnionProducerEntry :: from) } # [allow (dead_code)] pub fn transform < F : :: std :: ops :: FnOnce () -> Input > (& self , transformer : F) -> :: fastfifo :: transform :: Result < () > { self . get_entry () . map (| mut entry | entry . transform (transformer)) } } pub struct InOutUnionTransformerEntry < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > (:: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >) ; impl < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > From < :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >> for InOutUnionTransformerEntry < 'entry_descriptor_lifetime , Input , Output , A > { fn from (value : :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >) -> Self { Self (value) } } impl < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > Into < :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >> for InOutUnionTransformerEntry < 'entry_descriptor_lifetime , Input , Output , A > { fn into (self) -> :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A > { self . 0 } } impl < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > InOutUnionTransformerEntry < 'entry_descriptor_lifetime , Input , Output , A > { # [allow (dead_code)] pub fn transform < F : :: std :: ops :: FnOnce (Input) -> Output > (& mut self , transformer : F) { self . 0 . modify_t_in_place (| ptr | unsafe { ptr . write (InOutUnion { transformer : :: core :: mem :: ManuallyDrop :: new (transformer (< :: core :: mem :: ManuallyDrop :: < Input >> :: into_inner (ptr . read () . producer))) }) }) } } pub struct InOutUnionTransformerFifo < Input , Output , A : :: std :: alloc :: Allocator > (InOutUnionFifo < Input , Output , A >) ; impl < Input , Output , A : :: std :: alloc :: Allocator > :: fastfifo :: transform :: config :: TaggedClone < InOutUnionTag > for InOutUnionTransformerFifo < Input , Output , A > { fn unchecked_clone (& self) -> Self { Self (self . 0 . unchecked_clone ()) } } impl < Input , Output , A : :: std :: alloc :: Allocator > Clone for InOutUnionTransformerFifo < Input , Output , A > { fn clone (& self) -> Self { < Self as :: fastfifo :: transform :: config :: TaggedClone < InOutUnionTag >> :: tagged_clone (& self , InOutUnionTag :: Transformer) . expect ("this variant was marked with `atomic = false` and cannot be cloned") } } impl < Input , Output , A : :: std :: alloc :: Allocator > InOutUnionTransformerFifo < Input , Output , A > { # [allow (dead_code)] pub fn get_entry < 'entry_descriptor_lifetime > (& 'entry_descriptor_lifetime self) -> :: fastfifo :: transform :: Result < InOutUnionTransformerEntry < 'entry_descriptor_lifetime , Input , Output , A > > { self . 0 . get_entry (InOutUnionTag :: Transformer) . map (InOutUnionTransformerEntry :: from) } # [allow (dead_code)] pub fn transform < F : :: std :: ops :: FnOnce (Input) -> Output > (& self , transformer : F) -> :: fastfifo :: transform :: Result < () > { self . get_entry () . map (| mut entry | entry . transform (transformer)) } } pub struct InOutUnionConsumerEntry < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > (:: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >) ; impl < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > From < :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >> for InOutUnionConsumerEntry < 'entry_descriptor_lifetime , Input , Output , A > { fn from (value : :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >) -> Self { Self (value) } } impl < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > Into < :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A >> for InOutUnionConsumerEntry < 'entry_descriptor_lifetime , Input , Output , A > { fn into (self) -> :: fastfifo :: transform :: entry_descriptor :: EntryDescriptor < 'entry_descriptor_lifetime , InOutUnionTag , InOutUnion < Input , Output > , A > { self . 0 } } impl < 'entry_descriptor_lifetime , Input , Output , A : :: std :: alloc :: Allocator > InOutUnionConsumerEntry < 'entry_descriptor_lifetime , Input , Output , A > { # [allow (dead_code)] pub fn transform < F : :: std :: ops :: FnOnce (Output) > (& mut self , transformer : F) { self . 0 . modify_t_in_place (| ptr | unsafe { transformer (< :: core :: mem :: ManuallyDrop :: < Output >> :: into_inner (ptr . read () . transformer)) }) } } pub struct InOutUnionConsumerFifo < Input , Output , A : :: std :: alloc :: Allocator > (InOutUnionFifo < Input , Output , A >) ; impl < Input , Output , A : :: std :: alloc :: Allocator > :: fastfifo :: transform :: config :: TaggedClone < InOutUnionTag > for InOutUnionConsumerFifo < Input , Output , A > { fn unchecked_clone (& self) -> Self { Self (self . 0 . unchecked_clone ()) } } impl < Input , Output , A : :: std :: alloc :: Allocator > Clone for InOutUnionConsumerFifo < Input , Output , A > { fn clone (& self) -> Self { < Self as :: fastfifo :: transform :: config :: TaggedClone < InOutUnionTag >> :: tagged_clone (& self , InOutUnionTag :: Consumer) . expect ("this variant was marked with `atomic = false` and cannot be cloned") } } impl < Input , Output , A : :: std :: alloc :: Allocator > InOutUnionConsumerFifo < Input , Output , A > { # [allow (dead_code)] pub fn get_entry < 'entry_descriptor_lifetime > (& 'entry_descriptor_lifetime self) -> :: fastfifo :: transform :: Result < InOutUnionConsumerEntry < 'entry_descriptor_lifetime , Input , Output , A > > { self . 0 . get_entry (InOutUnionTag :: Consumer) . map (InOutUnionConsumerEntry :: from) } # [allow (dead_code)] pub fn transform < F : :: std :: ops :: FnOnce (Output) > (& self , transformer : F) -> :: fastfifo :: transform :: Result < () > { self . get_entry () . map (| mut entry | entry . transform (transformer)) } }